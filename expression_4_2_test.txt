Calculating AlgExpr

solving expr:  +8  +7  +6  *5  **(2  *2)  +10 

N               1  2     3  4    5     6    7 


('CalcExpr starts working. N=', 2)

length of expression = 7
given (sub)structure has type AlgExprPart
N: =2
there was no recursion. Expr from dataFlow N 2:  +7 
...  8 + 7 ...
Analyzing
Btackets of parts: prePart: open: 0 shut: 0; cuPart: open: 0 shut: 0
N=2<L=7
order of cur oper + is NOT greater than of cur oper  => calculating this part
Now part of expr: ... 8 +  7 + ...
order of next oper + is NOT greater than of cur oper + => calculating this part
Calc starts working/ x1=8 op=1 x2=7
 op=+
 opN=1
answer: y=15 Calc finishes working
N=N+1=3, (going to next cycle step)
(N=3 L=7 Ngiven=1 -it is not last expr part)
N: =3
there was no recursion. Expr from dataFlow N 3:  +6 
...  15 + 6 ...
Analyzing
Btackets of parts: prePart: open: 0 shut: 0; cuPart: open: 0 shut: 0
N=3<L=7
order of cur oper + is NOT greater than of cur oper + => calculating this part
Now part of expr: ... 15 +  6 * ...
order of next oper + IS greater than of cur oper *
(cur part: 0brackets open)

starting recursion with ini expr data: N=3 pre expr part:  +6 

('CalcExpr starts working. N=', 4)

length of expression = 7
given (sub)structure has type AlgExprPart
N: =4
there was no recursion. Expr from dataFlow N 4:  *5 
... + 6 * 5 ...
Analyzing
Btackets of parts: prePart: open: 0 shut: 0; cuPart: open: 0 shut: 0
N=4<L=7
order of cur oper * is NOT greater than of cur oper  => calculating this part
Now part of expr: ...+ 6 *  5 ** ...
order of next oper * IS greater than of cur oper **
(cur part: 0brackets open)

starting recursion with ini expr data: N=4 pre expr part:  *5
 
('CalcExpr starts working. N=', 5) #  

length of expression = 7
given (sub)structure has type AlgExprPart
N: =5
there was no recursion. Expr from dataFlow N 5:  **(2 
... * 5 ** 2 ...
Analyzing
Btackets of parts: prePart: open: 0 shut: 0; cuPart: open: 1 shut: 0
N=5<L=7
order of cur oper ** is NOT greater than of cur oper  => calculating this part
cur oper (after prev): brackets open: 1
Now part of expr: ...* 5 **  2 * ...
(order of next oper ** is NOT greater than of cur oper *)
cur part: brackets open: 1

starting recursion with ini expr data: N=5 pre expr part:  **(2 

('CalcExpr starts working. N=', 6)

length of expression = 7
given (sub)structure has type AlgExprPart
N: =6
there was no recursion. Expr from dataFlow N 6:  *2) 
... ** 2 * 2 ...

Bracket open (left: 0). Starting recursion (ob ()) with operand=2, operator=0, N=6 # ! tic irr recursio

('CalcExpr starts working. N=', 6)

length of expression = 7
given (sub)structure has type AlgExprPart
N: =6
there was no recursion. Expr from dataFlow N 6:  *2) 
...  2 * 2 ...
Analyzing
Btackets of parts: prePart: open: 0 shut: 0; cuPart: open: 0 shut: 1
(order of cur oper is NOT greater than of prev)
case 3.3 brackets shut
expr now is : +2 
shut brackets: 1 -> 0
Now cur part= *2 ( N=6)

CalcExpr finishes working. Ngiven=6 N=6 yR=2(full expr  +0 )
CalcExpr finishes working. Ngiven=6 N=6 yR=0(full expr  +2 )

returned from recursion to Ngiven=5, from N=0-1=-1 now next part:  +0 

(N=-1 L=7 Ngiven=5 -it is not last expr part)
N: =-1
there was  recursion in jef cycle step (jef'l cycle step, jef-step o'cycle, jef-cycle-step). Expr an ef'y calc'd recursio data:  +0 ( N=-1)
... * 5 + 0 ...
Analyzing
Btackets of parts: prePart: open: 0 shut: 0; cuPart: open: 0 shut: 0
case 3.1 order of cur oper + is NOT higher than of PREV oper * => returning
expr now is : +5 
Now cur part= +0 ( N=-1)
CalcExpr finishes working. Ngiven=5 N=-1 yR=5(full expr  +0 )
returned from recursion to Ngiven=4, from N=-1-1=-2 now next part:  +5 
(N=-2 L=7 Ngiven=4 -it is not last expr part)
N: =-2
there was  recursion in jef cycle step (jef'l cycle step, jef-step o'cycle, jef-cycle-step). Expr an ef'y calc'd recursio data:  +5 ( N=-2)
... + 6 + 5 ...
Analyzing
Btackets of parts: prePart: open: 0 shut: 0; cuPart: open: 0 shut: 0
case 3.1 order of cur oper + is NOT higher than of PREV oper + => returning
expr now is : +6 
Now cur part= +5 ( N=-2)
CalcExpr finishes working. Ngiven=4 N=-2 yR=6(full expr  +5 )
returned from recursion to Ngiven=1, from N=-2-1=-3 now next part:  +6 
(N=-3 L=7 Ngiven=1 -it is not last expr part)
N: =-3
there was  recursion in jef cycle step (jef'l cycle step, jef-step o'cycle, jef-cycle-step). Expr an ef'y calc'd recursio data:  +6 ( N=-3)
...  15 + 6 ...
Analyzing
Btackets of parts: prePart: open: 0 shut: 0; cuPart: open: 0 shut: 0
N=-3<L=7
order of cur oper + is NOT greater than of cur oper * => calculating this part
Now part of expr: ... 15 +  6  ...
order of next oper + is NOT greater than of cur oper  => calculating this part
Calc starts working/ x1=15 op=1 x2=6
 op=+
 opN=1
answer: y=21 Calc finishes working
N=N+1=-2, (going to next cycle step)
(N=-2 L=7 Ngiven=1 -it is not last expr part)
N: =-2
there was no recursion. Expr from dataFlow N -2:  (.unknown.)2 
...  21  2 ...
Analyzing
Btackets of parts: prePart: open: 0 shut: 0; cuPart: open: 0 shut: 0
case 3.1 order of cur oper  is NOT higher than of PREV oper  => returning
expr now is : (.unknown.)21 
Now cur part= (.unknown.)2 ( N=-2)
CalcExpr finishes working. Ngiven=1 N=-2 yR=21(full expr  (.unknown.)21 )
Answer: y=21 (last N=-2)
>>> 