Python 2.7.13 (v2.7.13:a06454b1afa1, Dec 17 2016, 20:53:40) [MSC v.1500 64 bit (AMD64)] on win32
Type "copyright", "credits" or "license()" for more information.
>>> 
========= RESTART: D:\MyFilesCur\MyPrgs\Python\Test_CalcExpr_4_2.py =========
Calculating Query

solving expr: 10 == 11 or 12 == 12 or 13 != 12 and14 >  15 and16 == 16 or 
('CalcExpr starts working. N=', 2)
length of expression = 5
('val1=', 10, ' != val2=', 11)
given (sub)structure has type QueryPart
('val1=', 10, ' != val2=', 11)
N: =2
there was no recursion. Expr from dataFlow N 2: 12 == 12 or 
('val1=', 12, ' = val2=', 12)
...  0 + 1 ...
Analyzing
Btackets of parts: prePart: open: 0 shut: 0; cuPart: open: 0 shut: 0
N=2<L=5
order of cur oper + is NOT greater than of cur oper  => calculating this part
Now part of expr: ... 0 +  1 - ...
order of next oper + is NOT greater than of cur oper - => calculating this part
(0, '+', 1, '=', 1)
N=N+1=3, (going to next cycle step)
(N=3 L=5 Ngiven=1 -it is not last expr part)
N: =3
there was no recursion. Expr from dataFlow N 3: 13 != 12 and
('val1=', 13, ' != val2=', 12)
...  1 - 1 ...
Analyzing
Btackets of parts: prePart: open: 0 shut: 0; cuPart: open: 0 shut: 0
N=3<L=5
order of cur oper - is NOT greater than of cur oper - => calculating this part
Now part of expr: ... 1 -  1 - ...
order of next oper - is NOT greater than of cur oper - => calculating this part
(1, '*', 1, '=', 1)
N=N+1=4, (going to next cycle step)
(N=4 L=5 Ngiven=1 -it is not last expr part)
N: =4
there was no recursion. Expr from dataFlow N 4: 14 >  15 and
('val1=', 14, ' <= val2=', 15)
...  1 - 0 ...
Analyzing
Btackets of parts: prePart: open: 0 shut: 0; cuPart: open: 0 shut: 0
N=4<L=5
order of cur oper - is NOT greater than of cur oper - => calculating this part
Now part of expr: ... 1 -  0 + ...
order of next oper - is NOT greater than of cur oper + => calculating this part
(1, '*', 0, '=', 0)
N=N+1=5, (going to next cycle step)
N=5 L=5 Ngiven=1 -last expr reached now
going to next cycle step with: N=5 Ngiven=1 expr part: 14 >  15 or 
N: =5
there was no recursion. Expr from dataFlow N 5: 16 == 16 or 
('val1=', 16, ' = val2=', 16)
...  0 + 1 ...
Analyzing
Btackets of parts: prePart: open: 0 shut: 0; cuPart: open: 0 shut: 0
(order of cur oper is NOT greater than of prev)
case 3.2 last_expr_part reached
(0, '+', 1, '=', 1)
expr now is :0 == 0 or 
(N=5=L=5 - and last expr part reached)
Now cur part=16 == 16 or ( N=5)
('val1=', 0, ' = val2=', 0)
CalcExpr finishes working. Ngiven=1 N=5 yR=1(full expr 0 == 0 and)
('val1=', 0, ' = val2=', 0)
Answer: y=1 (last N=5)


Calculating AlgExpr

solving expr:  +8  +7  +6  *5  **(2  *2)  +10 
('CalcExpr starts working. N=', 2)
length of expression = 7
given (sub)structure has type AlgExprPart
N: =2
there was no recursion. Expr from dataFlow N 2:  +7 
...  8 + 7 ...
Analyzing
Btackets of parts: prePart: open: 0 shut: 0; cuPart: open: 0 shut: 0
N=2<L=7
order of cur oper + is NOT greater than of cur oper  => calculating this part
Now part of expr: ... 8 +  7 + ...
order of next oper + is NOT greater than of cur oper + => calculating this part
Calc starts working/ x1=8 op=1 x2=7
 op=+
 opN=1
answer: y=15 Calc finishes working
N=N+1=3, (going to next cycle step)
(N=3 L=7 Ngiven=1 -it is not last expr part)
N: =3
there was no recursion. Expr from dataFlow N 3:  +6 
...  15 + 6 ...
Analyzing
Btackets of parts: prePart: open: 0 shut: 0; cuPart: open: 0 shut: 0
N=3<L=7
order of cur oper + is NOT greater than of cur oper + => calculating this part
Now part of expr: ... 15 +  6 * ...
order of next oper + IS greater than of cur oper *
(cur part: _0_ brackets open)
starting recursion with ini expr data: N=3 pre expr part:  +6 
('CalcExpr starts working. N=', 4)
length of expression = 7
given (sub)structure has type AlgExprPart
N: =4
there was no recursion. Expr from dataFlow N 4:  *5 
... + 6 * 5 ...
Analyzing
Btackets of parts: prePart: open: 0 shut: 0; cuPart: open: 0 shut: 0
N=4<L=7
order of cur oper * is NOT greater than of cur oper  => calculating this part
Now part of expr: ...+ 6 *  5 ** ...
order of next oper * IS greater than of cur oper **
(cur part: _0_ brackets open)
starting recursion with ini expr data: N=4 pre expr part:  *5 
('CalcExpr starts working. N=', 5)
length of expression = 7
given (sub)structure has type AlgExprPart
N: =5
there was no recursion. Expr from dataFlow N 5:  **(2 
... * 5 ** 2 ...
Analyzing
Btackets of parts: prePart: open: 0 shut: 0; cuPart: open: 1 shut: 0
N=5<L=7
order of cur oper ** is NOT greater than of cur oper  => calculating this part
cur oper (after prev): brackets open: 1
Now part of expr: ...* 5 **  2 * ...
(order of next oper ** is NOT greater than of cur oper *)
cur part: brackets open: 1
starting recursion with ini expr data: N=5 pre expr part:  **(2 
('CalcExpr starts working. N=', 6)
length of expression = 7
given (sub)structure has type AlgExprPart
N: =6
there was no recursion. Expr from dataFlow N 6:  *2) 
... ** 2 * 2 ...
Bracket open (left: 0). Starting recursion (ob ()) with operand=2, operator=0, N=6
('CalcExpr starts working. N=', 6)
length of expression = 7
given (sub)structure has type AlgExprPart
N: =6
there was no recursion. Expr from dataFlow N 6:  *2) 
...  2 * 2 ...
Analyzing
Btackets of parts: prePart: open: 0 shut: 0; cuPart: open: 0 shut: 1
(order of cur oper is NOT greater than of prev)
case 3.3 brackets shut
expr now is : +2 
shut brackets: 1 -> 0
Now cur part= *2 ( N=6)
CalcExpr finishes working. Ngiven=6 N=6 yR=2(full expr  +0 )
returned from recursion (ic ob ()). N=6=N=6 to Ngiven=6
CalcExpr finishes working. Ngiven=6 N=6 yR=0(full expr  +2 )
returned from recursion to Ngiven=5, from N=0-1=-1 now next part:  +0 
(N=-1 L=7 Ngiven=5 -it is not last expr part)
N: =-1
there was  recursion in jef cycle step (jef'l cycle step, jef-step o'cycle, jef-cycle-step). Expr an ef'y calc'd recursio data:  +0 ( N=-1)
... * 5 + 0 ...
Analyzing
Btackets of parts: prePart: open: 0 shut: 0; cuPart: open: 0 shut: 0
case 3.1 order of cur oper + is NOT higher than of PREV oper * => returning
expr now is : +5 
Now cur part= +0 ( N=-1)
CalcExpr finishes working. Ngiven=5 N=-1 yR=5(full expr  +0 )
returned from recursion to Ngiven=4, from N=-1-1=-2 now next part:  +5 
(N=-2 L=7 Ngiven=4 -it is not last expr part)
N: =-2
there was  recursion in jef cycle step (jef'l cycle step, jef-step o'cycle, jef-cycle-step). Expr an ef'y calc'd recursio data:  +5 ( N=-2)
... + 6 + 5 ...
Analyzing
Btackets of parts: prePart: open: 0 shut: 0; cuPart: open: 0 shut: 0
case 3.1 order of cur oper + is NOT higher than of PREV oper + => returning
expr now is : +6 
Now cur part= +5 ( N=-2)
CalcExpr finishes working. Ngiven=4 N=-2 yR=6(full expr  +5 )
returned from recursion to Ngiven=1, from N=-2-1=-3 now next part:  +6 
(N=-3 L=7 Ngiven=1 -it is not last expr part)
N: =-3
there was  recursion in jef cycle step (jef'l cycle step, jef-step o'cycle, jef-cycle-step). Expr an ef'y calc'd recursio data:  +6 ( N=-3)
...  15 + 6 ...
Analyzing
Btackets of parts: prePart: open: 0 shut: 0; cuPart: open: 0 shut: 0
N=-3<L=7
order of cur oper + is NOT greater than of cur oper * => calculating this part
Now part of expr: ... 15 +  6  ...
order of next oper + is NOT greater than of cur oper  => calculating this part
Calc starts working/ x1=15 op=1 x2=6
 op=+
 opN=1
answer: y=21 Calc finishes working
N=N+1=-2, (going to next cycle step)
(N=-2 L=7 Ngiven=1 -it is not last expr part)
N: =-2
there was no recursion. Expr from dataFlow N -2:  (.unknown.)2 
...  21  2 ...
Analyzing
Btackets of parts: prePart: open: 0 shut: 0; cuPart: open: 0 shut: 0
case 3.1 order of cur oper  is NOT higher than of PREV oper  => returning
expr now is : (.unknown.)21 
Now cur part= (.unknown.)2 ( N=-2)
CalcExpr finishes working. Ngiven=1 N=-2 yR=21(full expr  (.unknown.)21 )
Answer: y=21 (last N=-2)
>>> 
========= RESTART: D:\MyFilesCur\MyPrgs\Python\Test_CalcExpr_4_2.py =========
Calculating Query

solving expr: 10 == 11 or 12 == 12 or 13 != 12 and14 >  15 and16 == 16 or 
('CalcExpr starts working. N=', 2)
length of expression = 5
('val1=', 10, ' != val2=', 11)
given (sub)structure has type QueryPart
('val1=', 10, ' != val2=', 11)
N: =2
there was no recursion. Expr from dataFlow N 2: 12 == 12 or 
('val1=', 12, ' = val2=', 12)
...  0 + 1 ...
Analyzing
Btackets of parts: prePart: open: 0 shut: 0; cuPart: open: 0 shut: 0
N=2<L=5
order of cur oper + is NOT greater than of cur oper  => calculating this part
Now part of expr: ... 0 +  1 - ...
order of next oper + is NOT greater than of cur oper - => calculating this part
(0, '+', 1, '=', 1)
N=N+1=3, (going to next cycle step)
(N=3 L=5 Ngiven=1 -it is not last expr part)
N: =3
there was no recursion. Expr from dataFlow N 3: 13 != 12 and
('val1=', 13, ' != val2=', 12)
...  1 - 1 ...
Analyzing
Btackets of parts: prePart: open: 0 shut: 0; cuPart: open: 0 shut: 0
N=3<L=5
order of cur oper - is NOT greater than of cur oper - => calculating this part
Now part of expr: ... 1 -  1 - ...
order of next oper - is NOT greater than of cur oper - => calculating this part
(1, '*', 1, '=', 1)
N=N+1=4, (going to next cycle step)
(N=4 L=5 Ngiven=1 -it is not last expr part)
N: =4
there was no recursion. Expr from dataFlow N 4: 14 >  15 and
('val1=', 14, ' <= val2=', 15)
...  1 - 0 ...
Analyzing
Btackets of parts: prePart: open: 0 shut: 0; cuPart: open: 0 shut: 0
N=4<L=5
order of cur oper - is NOT greater than of cur oper - => calculating this part
Now part of expr: ... 1 -  0 + ...
order of next oper - is NOT greater than of cur oper + => calculating this part
(1, '*', 0, '=', 0)
N=N+1=5, (going to next cycle step)
N=5 L=5 Ngiven=1 -last expr reached now
going to next cycle step with: N=5 Ngiven=1 expr part: 14 >  15 or 
N: =5
there was no recursion. Expr from dataFlow N 5: 16 == 16 or 
('val1=', 16, ' = val2=', 16)
...  0 + 1 ...
Analyzing
Btackets of parts: prePart: open: 0 shut: 0; cuPart: open: 0 shut: 0
(order of cur oper is NOT greater than of prev)
case 3.2 last_expr_part reached
(0, '+', 1, '=', 1)
expr now is :0 == 0 or 
(N=5=L=5 - and last expr part reached)
Now cur part=16 == 16 or ( N=5)
('val1=', 0, ' = val2=', 0)
CalcExpr finishes working. Ngiven=1 N=5 yR=1(full expr 0 == 0 and)
('val1=', 0, ' = val2=', 0)
Answer: y=1 (last N=5)


Calculating AlgExpr

solving expr:  +8  +7  +6  *5  **2  *2  +10 
('CalcExpr starts working. N=', 2)
length of expression = 7
given (sub)structure has type AlgExprPart
N: =2
there was no recursion. Expr from dataFlow N 2:  +7 
...  8 + 7 ...
Analyzing
Btackets of parts: prePart: open: 0 shut: 0; cuPart: open: 0 shut: 0
N=2<L=7
order of cur oper + is NOT greater than of cur oper  => calculating this part
Now part of expr: ... 8 +  7 + ...
order of next oper + is NOT greater than of cur oper + => calculating this part
Calc starts working/ x1=8 op=1 x2=7
 op=+
 opN=1
answer: y=15 Calc finishes working
N=N+1=3, (going to next cycle step)
(N=3 L=7 Ngiven=1 -it is not last expr part)
N: =3
there was no recursion. Expr from dataFlow N 3:  +6 
...  15 + 6 ...
Analyzing
Btackets of parts: prePart: open: 0 shut: 0; cuPart: open: 0 shut: 0
N=3<L=7
order of cur oper + is NOT greater than of cur oper + => calculating this part
Now part of expr: ... 15 +  6 * ...
order of next oper + IS greater than of cur oper *
(cur part: _0_ brackets open)
starting recursion with ini expr data: N=3 pre expr part:  +6 
('CalcExpr starts working. N=', 4)
length of expression = 7
given (sub)structure has type AlgExprPart
N: =4
there was no recursion. Expr from dataFlow N 4:  *5 
... + 6 * 5 ...
Analyzing
Btackets of parts: prePart: open: 0 shut: 0; cuPart: open: 0 shut: 0
N=4<L=7
order of cur oper * is NOT greater than of cur oper  => calculating this part
Now part of expr: ...+ 6 *  5 ** ...
order of next oper * IS greater than of cur oper **
(cur part: _0_ brackets open)
starting recursion with ini expr data: N=4 pre expr part:  *5 
('CalcExpr starts working. N=', 5)
length of expression = 7
given (sub)structure has type AlgExprPart
N: =5
there was no recursion. Expr from dataFlow N 5:  **2 
... * 5 ** 2 ...
Analyzing
Btackets of parts: prePart: open: 0 shut: 0; cuPart: open: 0 shut: 0
N=5<L=7
order of cur oper ** is NOT greater than of cur oper  => calculating this part
Now part of expr: ...* 5 **  2 * ...
order of next oper ** is NOT greater than of cur oper * => calculating this part
Calc starts working/ x1=5 op=5 x2=2
 op=**
 opN=5
answer: y=25 Calc finishes working
N=N+1=6, (going to next cycle step)
(N=6 L=7 Ngiven=5 -it is not last expr part)
N: =6
there was no recursion. Expr from dataFlow N 6:  *2 
... * 25 * 2 ...
Analyzing
Btackets of parts: prePart: open: 0 shut: 0; cuPart: open: 0 shut: 0
case 3.1 order of cur oper * is NOT higher than of PREV oper * => returning
expr now is : *25 
Now cur part= *2 ( N=6)
CalcExpr finishes working. Ngiven=5 N=6 yR=25(full expr  +0 )
returned from recursion to Ngiven=4, from N=6-1=5 now next part:  *25 
(N=5 L=7 Ngiven=4 -it is not last expr part)
N: =5
there was  recursion in jef cycle step (jef'l cycle step, jef-step o'cycle, jef-cycle-step). Expr an ef'y calc'd recursio data:  *25 ( N=5)
... + 6 * 25 ...
Analyzing
Btackets of parts: prePart: open: 0 shut: 0; cuPart: open: 0 shut: 0
N=5<L=7
order of cur oper * is NOT greater than of cur oper ** => calculating this part
Now part of expr: ...+ 6 *  25 * ...
order of next oper * is NOT greater than of cur oper * => calculating this part
Calc starts working/ x1=6 op=3 x2=25
 op=*
 opN=3
answer: y=150 Calc finishes working
N=N+1=6, (going to next cycle step)
(N=6 L=7 Ngiven=4 -it is not last expr part)
N: =6
there was no recursion. Expr from dataFlow N 6:  *2 
... + 150 * 2 ...
Analyzing
Btackets of parts: prePart: open: 0 shut: 0; cuPart: open: 0 shut: 0
N=6<L=7
order of cur oper * is NOT greater than of cur oper * => calculating this part
Now part of expr: ...+ 150 *  2 + ...
order of next oper * is NOT greater than of cur oper + => calculating this part
Calc starts working/ x1=150 op=3 x2=2
 op=*
 opN=3
answer: y=300 Calc finishes working
N=N+1=7, (going to next cycle step)
N=7 L=7 Ngiven=4 -last expr reached now
going to next cycle step with: N=7 Ngiven=4 expr part:  +300 
N: =7
there was no recursion. Expr from dataFlow N 7:  +10 
... + 300 + 10 ...
Analyzing
Btackets of parts: prePart: open: 0 shut: 0; cuPart: open: 0 shut: 0
case 3.1 order of cur oper + is NOT higher than of PREV oper + => returning
case 3.2 last_expr_part reached
last expr reached, but not in ext fn - no calc provided
expr now is : +300 
(N=7=L=7 - and last expr part reached)
Now cur part= +10 ( N=7)
CalcExpr finishes working. Ngiven=4 N=7 yR=300(full expr  *150 )
returned from recursion to Ngiven=1, from N=7-1=6 now next part:  +300 
(N=6 L=7 Ngiven=1 -it is not last expr part)
N: =6
there was  recursion in jef cycle step (jef'l cycle step, jef-step o'cycle, jef-cycle-step). Expr an ef'y calc'd recursio data:  +300 ( N=6)
...  15 + 300 ...
Analyzing
Btackets of parts: prePart: open: 0 shut: 0; cuPart: open: 0 shut: 0
N=6<L=7
order of cur oper + is NOT greater than of cur oper * => calculating this part
Now part of expr: ... 15 +  300 + ...
order of next oper + is NOT greater than of cur oper + => calculating this part
Calc starts working/ x1=15 op=1 x2=300
 op=+
 opN=1
answer: y=315 Calc finishes working
N=N+1=7, (going to next cycle step)
N=7 L=7 Ngiven=1 -last expr reached now
going to next cycle step with: N=7 Ngiven=1 expr part:  +315 
N: =7
there was no recursion. Expr from dataFlow N 7:  +10 
...  315 + 10 ...
Analyzing
Btackets of parts: prePart: open: 0 shut: 0; cuPart: open: 0 shut: 0
(order of cur oper is NOT greater than of prev)
case 3.2 last_expr_part reached
Calc starts working/ x1=315 op=1 x2=10
 op=+
 opN=1
answer: y=325 Calc finishes working
expr now is : +325 
(N=7=L=7 - and last expr part reached)
Now cur part= +10 ( N=7)
CalcExpr finishes working. Ngiven=1 N=7 yR=325(full expr  +315 )
Answer: y=325 (last N=7)
>>> 